{"meta":{"title":"个人博客","subtitle":null,"description":null,"author":"codeliu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"浅谈Spring框架的IOC与AOP","slug":"IOC与AOP","date":"2018-05-30T09:56:57.830Z","updated":"2018-05-31T02:05:00.714Z","comments":true,"path":"2018/05/30/IOC与AOP/","link":"","permalink":"http://yoursite.com/2018/05/30/IOC与AOP/","excerpt":"","text":"IOCIOC(控制反转)又称依赖注入，是整个spring的核心，贯穿始终。学过Java的都知道，当我们需要使用一个对象的时候，首先得new object(),我们需要关注对象的生命周期，什么时候创建，什么时候销毁都得自己来维护，例如数据库的连接对象，如果我们忘记关闭会造成很严重的问题。这时候IOC的优势就显示出来了，我们把对象放到IOC容器中，需要的时候直接拿来用，用完的时候什么也不用管，这样是不是很方便省心？再通俗一点就好比找对象，传统方法是到处去找符合我们要求的妹子然后发展，现在IOC相当于一个婚介所，各种各样的妹子都在IOC容器中登记，然后我把我们的条件告诉婚介所，然后婚介所找到符合条件的妹子自动匹配给我们。 下面来通过代码理解一下Spring是怎么运行的123456public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext( &quot;applicationContext.xml&quot;); Animal animal = (Animal) context.getBean(&quot;animal&quot;); animal.say(); &#125; 这段代码大家应该都很熟悉吧，一步步讲解，先来看看 applicationContext.xml123&lt;bean id=&quot;animal&quot; class=&quot;phz.springframework.test.Cat&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;kitty&quot; /&gt; &lt;/bean&gt; 一个animal的实现类123456789public class Cat implements Animal &#123; private String name; public void say() &#123; System.out.println(&quot;I am &quot; + name + &quot;!&quot;); &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; Animal接口123public interface Animal &#123; public void say(); &#125; 很明显上面的代码输出“I am kitty !”,那么spring是怎么实现的，往下看，我们简单分析一下原理 Spring开始加载配置文件的时候，会把信息保存再一个HashMap中，HashMap的key就是id,HashMap的value就是class,那么他还有一个name属性怎么办呢，其实这也会保存在一个HashMap中。1234Map&lt;String, String&gt; beans = new HashMap&lt;String, String&gt;(); beans.put(&quot;animal&quot;,&quot;kitty&quot;);Map&lt;String, Object&gt; propertiesMap = new HashMap&lt;String, Object&gt;(); propertiesMap.put(&quot;name&quot;,&quot;kitty&quot;); 接下来就是最核心的部分了，首先反射找到这个类和属性123456789101112131415public static Object newInstance(String className) &#123; Class&lt;?&gt; cls = null; Object obj = null; try &#123; cls = Class.forName(className); obj = cls.newInstance(); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; catch (InstantiationException e) &#123; throw new RuntimeException(e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; return obj; &#125; 接着将这个类的属性注入进去12345678910111213141516171819202122232425public static void setProperty(Object obj, String name, String value) &#123; Class&lt;? extends Object&gt; clazz = obj.getClass(); try &#123; String methodName = returnSetMthodName(name); Method[] ms = clazz.getMethods(); for (Method m : ms) &#123; if (m.getName().equals(methodName)) &#123; if (m.getParameterTypes().length == 1) &#123; Class&lt;?&gt; clazzParameterType = m.getParameterTypes()[0]; setFieldValue(clazzParameterType.getName(), value, m, obj); break; &#125; &#125; &#125; &#125; catch (SecurityException e) &#123; throw new RuntimeException(e); &#125; catch (IllegalArgumentException e) &#123; throw new RuntimeException(e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException(e); &#125; &#125; 最后再把这个类的实例返回给我们，我们就可以使用了12345678910111213if (value instanceof Map) &#123; Iterator&lt;?&gt; entryIterator = ((Map&lt;?, ?&gt;) value).entrySet() .iterator(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); while (entryIterator.hasNext()) &#123; Entry&lt;?, ?&gt; entryMap = (Entry&lt;?, ?&gt;) entryIterator.next(); if (entryMap.getValue() instanceof String[]) &#123; map.put((String) entryMap.getKey(), getBean(((String[]) entryMap.getValue())[0])); &#125; &#125; BeanProcesser.setProperty(obj, property, map); &#125; 当然依赖注入不只就这么一点，这只是一个大致的思路，还需要慢慢研究理解。 AOPAOP即面向切面编程，实现是使用的代理技术，简单说一下代理，例如我们上淘宝买东西用支付宝付款的时候，并没有面对面或卡对卡的把钱给了商家，而是把钱转给了支付宝，支付宝再代我们把钱转给商家，其实这时支付宝就是一个代理接口，他会根据订单自动从买家的账户扣到卖家的账户。下面用代码来理解一下。首先我们有一个公共接口1234567public interface IHello &#123; /** * 业务方法 * @param str */ void sayHello(String str); &#125; 接着我们有一个目标类实现了这个接口123456public class Hello implements IHello&#123; @Override public void sayHello(String str) &#123; System.out.println(&quot;hello &quot;+str); &#125; &#125; 此时我们new一个Hello对象可以实现主要业务的方法，但是我们还不满足，有时想要在方法前后都加日志以便维护，这时我们定义了一个Logger类123456789public class Logger &#123; public static void start()&#123; System.out.println(new Date()+ &quot; say hello start...&quot;); &#125; public static void end()&#123; System.out.println(new Date()+ &quot; say hello end&quot;); &#125; &#125; 这样我们想打日志的时候就可以调用Logger类来打日志，但是我想打日志的情况有很多，每次都得单独调用一次吗，实际是不需要的，我们定义一个代理类，让代理类来打日志就可以了。12345678910111213public class ProxyHello implements IHello&#123; private IHello hello; public ProxyHello(IHello hello) &#123; super(); this.hello = hello; &#125; @Override public void sayHello(String str) &#123; Logger.start();//添加特定的方法 hello.sayHello(str); Logger.end(); &#125;&#125; 下面是测试类代码1234567public class Test &#123; public static void main(String[] args) &#123; IHello hello = new ProxyHello(new Hello());//如果我们需要日志功能，则使用代理类 //IHello hello = new Hello();//如果我们不需要日志功能则使用目标类 hello.sayHello(&quot;明天&quot;); &#125; &#125; 这样虽然可以实现代理，但是如果有很多的业务都需要加日志那就得写好多代理类，太麻烦了。现在就需要动态代理技术了，我们需要哪个类加日志就代理哪个类。动态代理得实现InvocationHandler接口12345678910111213141516171819202122232425public class DynaProxyHello implements InvocationHandler&#123; private Object target;//目标对象 /** * 通过反射来实例化目标对象 * @param object * @return */ public Object bind(Object object)&#123; this.target = object; return Proxy.newProxyInstance(this.target.getClass().getClassLoader(), this.target.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; Logger.start();//添加额外的方法 //通过反射机制来运行目标对象的方法 result = method.invoke(this.target, args); Logger.end(); return result; &#125; &#125; 测试类代码：1234567public class DynaTest &#123; public static void main(String[] args) &#123; IHello hello = (IHello) new DynaProxyHello().bind(new Hello());//如果我们需要日志功能，则使用代理类 //IHello hello = new Hello();//如果我们不需要日志功能则使用目标类 hello.sayHello(&quot;明天&quot;); &#125; &#125; 这样我们就实现了动态代理，但也是最简单的，后面还需要深入研究。 本篇博客参考了很多其他大神的博客加自己的理解写出，其中很重要的知识点就是反射，这也是Java的一个精髓，如果有版权侵犯，请与本人联系。","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]}]}