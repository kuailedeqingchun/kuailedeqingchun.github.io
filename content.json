{"meta":{"title":"个人博客","subtitle":null,"description":null,"author":"codeliu","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"浅谈Spring框架的IOC与AOP","slug":"IOC与AOP","date":"2018-05-30T09:56:57.830Z","updated":"2018-05-31T00:56:03.009Z","comments":true,"path":"2018/05/30/IOC与AOP/","link":"","permalink":"http://yoursite.com/2018/05/30/IOC与AOP/","excerpt":"","text":"IOCIOC(控制反转)又称依赖注入，是整个spring的核心，贯穿始终。学过Java的都知道，当我们需要使用一个对象的时候，首先得new object(),我们需要关注对象的生命周期，什么时候创建，什么时候销毁都得自己来维护，例如数据库的连接对象，如果我们忘记关闭会造成很严重的问题。这时候IOC的优势就显示出来了，我们把对象放到IOC容器中，需要的时候直接拿来用，用完的时候什么也不用管，这样是不是很方便省心？再通俗一点就好比找对象，传统方法是到处去找符合我们要求的妹子然后发展，现在IOC相当于一个婚介所，各种各样的妹子都在IOC容器中登记，然后我把我们的条件告诉婚介所，然后婚介所找到符合条件的妹子自动匹配给我们。 下面来通过代码理解一下Spring是怎么运行的12345678public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext( &quot;applicationContext.xml&quot;); Animal animal = (Animal) context.getBean(&quot;animal&quot;); animal.say(); &#125; 这段代码大家应该都很熟悉吧，一步步讲解，先来看看 applicationContext.xml 1一个animal的实现类 public class Cat implements Animal { private String name; public void say() { System.out.println(“I am “ + name + “!”); } public void setName(String name) { this.name = name; }}1Animal接口 public interface Animal { public void say();}1234很明显上面的代码输出“I am kitty !”,那么spring是怎么实现的，往下看，我们简单分析一下原理 Spring开始加载配置文件的时候，会把信息保存再一个HashMap中，HashMap的key就是id,HashMap的value就是class,那么他还有一个name属性怎么办呢，其实这也会保存在一个HashMap中。 Map&lt;String, String&gt; beans = new HashMap&lt;String, String&gt;();beans.put(“animal”,”kitty”);Map&lt;String, Object&gt; propertiesMap = new HashMap&lt;String, Object&gt;();propertiesMap.put(“name”,”kitty”);1接下来就是最核心的部分了，首先反射找到这个类和属性 public static Object newInstance(String className) { Class&lt;?&gt; cls = null; Object obj = null; try { cls = Class.forName(className); obj = cls.newInstance(); } catch (ClassNotFoundException e) { throw new RuntimeException(e); } catch (InstantiationException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } return obj; }1接着将这个类的属性注入进去 public static void setProperty(Object obj, String name, String value) { Class&lt;? extends Object&gt; clazz = obj.getClass(); try { String methodName = returnSetMthodName(name); Method[] ms = clazz.getMethods(); for (Method m : ms) { if (m.getName().equals(methodName)) { if (m.getParameterTypes().length == 1) { Class&lt;?&gt; clazzParameterType = m.getParameterTypes()[0]; setFieldValue(clazzParameterType.getName(), value, m, obj); break; } } } } catch (SecurityException e) { throw new RuntimeException(e); } catch (IllegalArgumentException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } catch (InvocationTargetException e) { throw new RuntimeException(e); }}1最后再把这个类的实例返回给我们，我们就可以使用了 if (value instanceof Map) { Iterator&lt;?&gt; entryIterator = ((Map&lt;?, ?&gt;) value).entrySet() .iterator(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); while (entryIterator.hasNext()) { Entry&lt;?, ?&gt; entryMap = (Entry&lt;?, ?&gt;) entryIterator.next(); if (entryMap.getValue() instanceof String[]) { map.put((String) entryMap.getKey(), getBean(((String[]) entryMap.getValue())[0])); } } BeanProcesser.setProperty(obj, property, map); }1234567当然依赖注入不只就这么一点，这只是一个大致的思路，还需要慢慢研究理解。 ## AOP AOP即面向切面编程，实现是使用的代理技术，简单说一下代理，例如我们上淘宝买东西用支付宝付款的时候，并没有面对面或卡对卡的把钱给了商家，而是把钱转给了支付宝，支付宝再代我们把钱转给商家，其实这时支付宝就是一个代理接口，他会根据订单自动从买家的账户扣到卖家的账户。下面用代码来理解一下。 首先我们有一个公共接口 public interface IHello { /** * 业务方法 * @param str */ void sayHello(String str); }1234567891011121314151617181920212223242526272829303132333435363738接着我们有一个目标类实现了这个接口 ``` public class Hello implements IHello&#123; @Override public void sayHello(String str) &#123; System.out.println(&quot;hello &quot;+str); &#125; &#125; ``` 此时我们new一个Hello对象可以实现主要业务的方法，但是我们还不满足，有时想要在方法前后都加日志以便维护，这时我们定义了一个Logger类 ``` public class Logger &#123; public static void start()&#123; System.out.println(new Date()+ &quot; say hello start...&quot;); &#125; public static void end()&#123; System.out.println(new Date()+ &quot; say hello end&quot;); &#125; &#125; ``` 这样我们想打日志的时候就可以调用Logger类来打日志，但是我想打日志的情况有很多，每次都得单独调用一次吗，实际是不需要的，我们定义一个代理类，让代理类来打日志就可以了。 ``` public class ProxyHello implements IHello&#123; private IHello hello; public ProxyHello(IHello hello) &#123; super(); this.hello = hello; &#125; @Override public void sayHello(String str) &#123; Logger.start();//添加特定的方法 hello.sayHello(str); Logger.end(); &#125;&#125; 下面是测试类代码12345678910111213141516171819202122232425262728293031323334353637public class Test &#123; public static void main(String[] args) &#123; IHello hello = new ProxyHello(new Hello());//如果我们需要日志功能，则使用代理类 //IHello hello = new Hello();//如果我们不需要日志功能则使用目标类 hello.sayHello(&quot;明天&quot;); &#125; &#125; ``` 这样虽然可以实现代理，但是如果有很多的业务都需要加日志那就得写好多代理类，太麻烦了。现在就需要动态代理技术了，我们需要哪个类加日志就代理哪个类。 动态代理得实现InvocationHandler接口 ``` public class DynaProxyHello implements InvocationHandler&#123; private Object target;//目标对象 /** * 通过反射来实例化目标对象 * @param object * @return */ public Object bind(Object object)&#123; this.target = object; return Proxy.newProxyInstance(this.target.getClass().getClassLoader(), this.target.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; Logger.start();//添加额外的方法 //通过反射机制来运行目标对象的方法 result = method.invoke(this.target, args); Logger.end(); return result; &#125; &#125; 测试类代码：1234567public class DynaTest &#123; public static void main(String[] args) &#123; IHello hello = (IHello) new DynaProxyHello().bind(new Hello());//如果我们需要日志功能，则使用代理类 //IHello hello = new Hello();//如果我们不需要日志功能则使用目标类 hello.sayHello(&quot;明天&quot;); &#125; &#125; 这样我们就实现了动态代理，但也是最简单的，后面还需要深入研究。 本篇博客参考了很多其他大神的博客加自己的理解写出，其中很重要的知识点就是反射，这也是Java的一个精髓，如果有版权侵犯，请与本人联系。","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-26T02:49:30.032Z","updated":"2018-05-26T06:45:10.956Z","comments":true,"path":"2018/05/26/hello-world/","link":"","permalink":"http://yoursite.com/2018/05/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"ǰ��","slug":"j��","permalink":"http://yoursite.com/categories/j��/"}],"tags":[],"keywords":[{"name":"ǰ��","slug":"j��","permalink":"http://yoursite.com/categories/j��/"}]}]}